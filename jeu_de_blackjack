"""
Ce jeu permet de jouer au Black Jack:
    - seul, en multijoueur ou avec des IA
    - avec des mises

le dictionnaire joueurs est de la forme:

{
nom du premier joueur :{
                        'intelligence: 'humaine' ou 'artificielle',
                        'mains': [
                                    {
                                        'mise': mise associée, 
                                        'jeu': [
                                                    {
                                                        'valeur': valeur de la carte (str), 
                                                        'couleur': couleur de la carte (str)
                                                    }
                                                    , ...
                                                ], 
                                    },
                                    {...}
                                    ]
                        'richesse': richesse actuelle, dont on a déjà déduit la mise (int)
                        },

nom du deuxième joueur:...
}

mains contient plusieurs mains car split possible


croupier est de la forme: [{'valeur': valeur de la carte, 'couleur': couleur de la carte}, ...]
"""

import random as rd
import json as js


def sauvegarde():
    """ sauvegarde le dictionnaire joueurs dans le fichier sauvegarde_partie """
    global joueurs
    sauvegarde_json = open("sauvegarde_partie", 'w')
    js.dump(joueurs, sauvegarde_json, sort_keys=True, indent=4)
    sauvegarde_json.close()


def initialisation_par_sauvegarde():
    """ retourne le dictionnaire joueurs de la partie précédente """
    sauvegarde_json = open("sauvegarde_partie", 'r')
    joueurs = sauvegarde_json.read()
    joueurs = js.loads(joueurs)
    sauvegarde_json.close()
    return joueurs


def creation_sabot():
    """ retourne une liste contenant toutes les cartes du sabot mélangées """
    valeurs = [str(i) for i in range(1, 11)] + ['J', 'Q', 'K']
    couleurs = ['pique', 'coeur', 'carreau', 'trefle']
    sabot = 6 * [{'valeur': valeur, 'couleur': couleur} for couleur in couleurs for valeur in valeurs]
    rd.shuffle(sabot)
    return sabot


def mise_totale(mains: list):
    """
    Renvoie la mise totale de la main
    """
    S = 0
    for main in mains:
        S += main['mise']

    return S


def score(main: list):
    """
    calcule la valeur totale d'une main et renvoie [vmin, vmax]
    (deux éléments car valeur dépend des AS et 2 valeurs idéales possibles selon le contexte)
    """
    AS = 0
    total = 0
    for carte in main:
        if carte['valeur'] in ['10', 'J', 'Q', 'K']:
            total += 10

        elif carte['valeur'] == '1':
            AS += 1

        else:
            total += int(carte['valeur'])

    total_min = total + AS

    if AS == 0:
        total_max = total
    else:
        total_max = total + 11 * AS - AS + 1

    return {'min': total_min, 'max': total_max}


def detect_black_jack(main: list):
    """
    Vérifie pour tous les joueurs s'ils ont Black Jack,
    auquel cas ceux-ci réccupèrent 3/2 fois leur mise
    """
    return ((main[0]['valeur'] in ['10', 'J', 'Q', 'K'] and main[1]['valeur'] == '1')
            or (main[1]['valeur'] in ['10', 'J', 'Q', 'K'] and main[0]['valeur'] == '1'))


def choix(texte: str, alternatives: list):
    """
    Remplace les boutons en attendant une interface graphique,
    permet de simuler la sélection d'un bouton
    """
    action = input('\n' + texte)
    while action not in alternatives:

        action = input('\n' + texte)

    return action


def entree_valeur(texte: str):
    """
    Remplace temporairement la sélection de valeurs
    par jetons en attendant l'interface graphique
    """
    valeur = 1
    while valeur % 5 != 0 or valeur <= 0:
        valeur = int(input('\n' + texte))

    return valeur


def tirer(jeu: list):
    """ Fait tirer une carte au jeu """
    global sabot, joueurs
    jeu.append(sabot[-1])
    del sabot[-1]


def affichage(joueur: str):
    """ affiche clairement la situation de joueur """
    global joueurs
    print('\n' + joueur + ": ")
    print("richesse", joueurs[joueur]['richesse'])

    for indice_main in range(len(joueurs[joueur]['mains'])):
        print("\n", "main", indice_main, ":")
        print("   jeu:", joueurs[joueur]['mains'][indice_main]['jeu'])
        print("   mise associée", joueurs[joueur]['mains'][indice_main]['mise'])


def choix_nb_joueurs():
    """ retourne le nombre de joueurs demandé par l'utilisateur """
    nombre_de_joueurs = int(input("Indiquez le nombre de joueurs désiré (IA + joueurs réels) "))
    while not 0 < nombre_de_joueurs <= 7:
        nombre_de_joueurs = int(input("Indiquez le nombre de joueurs désiré (IA + joueurs réels) "))

    return nombre_de_joueurs


def creation_joueurs():
    """ Fait entrer leurs noms aux utilisateurs """
    joueurs = {}
    i = 0
    while i < nb_joueurs:
        joueur = str(input('\n' + 'Nom du nouveau joueur (si fin des joueurs humains ne rien écrire): '))

        if joueur == "":
            i = nb_joueurs

        elif joueur not in joueurs.keys():
            joueurs[joueur] = {'intelligence': 'humaine', 'mains': [{'mise': 0, 'jeu':  []}], 'richesse': 0}
            i += 1

    return joueurs


def creation_IA():
    """ Complète la liste de joueurs avec des IA pour qu'il y ait la bon nombre de joueurs """
    global joueurs, nb_joueurs
    liste_IA = [nom for nom in IA.keys()]
    rd.shuffle(liste_IA)
    for nom_IA in liste_IA:
        if not(nom_IA in joueurs.keys()) and len(joueurs) < nb_joueurs:
            joueurs[nom_IA] = {'intelligence': 'artificielle', 'mains': [[]], 'richesse': 0, 'mise': 0}


def initialisation_richesses():
    """ Demande la richesse de départ à l'utilisateur, puis l'assigne à chaque joueur """
    global joueurs
    richesse_initiale = entree_valeur("Richesse initiale? ")
    for joueur in joueurs.keys():
        joueurs[joueur]['richesse'] = richesse_initiale


def initialisation_mains():
    """ associe une main vide à chaque joueur """
    global croupier, joueurs
    croupier = []
    for joueur in joueurs.keys():
        joueurs[joueur]['mains'] = [{'mise': 0, 'jeu': []}]


def distribution():
    """
    distribue les cartes aux joueurs et au croupier
    dans le même ordre que dans la vraie vie au cas où ça pourrait aider pour l'interface graphique
    """
    global croupier, joueurs
    for repet in range(2):
        for joueur in joueurs.keys():
            tirer(joueurs[joueur]['mains'][0]['jeu'])

        tirer(croupier)


def mise_artificielle(joueur: str):
    """
    Fait miser l'intelligence artificielle correspondant au joueur
    (différentes prises de risque en fonction des IA)
    Ici version bêta à faire évoluer pour moins de répétition
    """
    global joueurs, IA
    mise = int(rd.uniform(0.5, 1.5) * IA[joueur] * joueurs[joueur]['richesse']) + 5
    mise += 5 - mise % 5
    joueurs[joueur]['mains'][0]['mise'] = min(mise, joueurs[joueur]['richesse'])


def mise_joueur(joueur: str):
    """ Fait choisir une mise au joueur jusqu'à ce que celle-ci soit inférieure à sa richesse """
    global joueurs
    valeur = entree_valeur(joueur + ", que voulez-vous miser? (votre richesse: " + str(joueurs[joueur]['richesse']) + ") ")
    while valeur > joueurs[joueur]['richesse']:
        valeur = entree_valeur("Cette mise est au-dessus de vos moyens. " +
                               joueur + ", que voulez-vous miser? ")

    joueurs[joueur]['mains'][0]['mise'] = valeur


def mise():
    """ Fait miser tout le monde """
    global joueurs
    for joueur in joueurs.keys():
        if joueurs[joueur]['intelligence'] == 'artificielle':
            mise_artificielle(joueur)

        else:
            mise_joueur(joueur)

        joueurs[joueur]['richesse'] -= joueurs[joueur]['mains'][0]['mise']


def black_jack():
    """
    après le début du tour, gére les cas où :
    - un joueur fait black jack
    - le croupier fait black jack
    - les deux à la fois

    L'arrondi pour congruence à 5 de la division d'une mise
    (lorsqu'un joueur remporte 3/2 de sa mise avantage le le joueur
    """
    global joueurs, croupier
    if detect_black_jack(croupier):
        print('\n', "le croupier a réalisé un black jack:", croupier)

        for joueur in joueurs:

            if detect_black_jack(joueurs[joueur]['mains'][0]['jeu']):
                joueurs[joueur]['richesse'] += joueurs[joueur]['mains'][0]['mise']
                print('\n', joueur, "a réalisé un black jack (",
                      joueurs[joueur]['mains'][0]['jeu'], ") il réccupère donc sa mise")

            else:
                print('\n', joueur, "n'a pas réalisé de black jack (",
                      joueurs[joueur]['mains'][0]['jeu'], ") il ne réccupère donc pas sa mise")

            joueurs[joueur]['mains'][0]['mise'] = 0
            joueurs[joueur]['mains'][0]['jeu'] = []

        croupier = []

    else:
        # la variable nb_black_jack sert à détecter le cas où tous les joueurs ont black jack
        for joueur in joueurs:
            if detect_black_jack(joueurs[joueur]['mains'][0]['jeu']):
                print('\n', "contrairement au croupier,", joueur, "a réalisé un black jack (", joueurs[joueur]['mains'][0]['jeu'],
                      ") il réccupère donc 3/2 de sa mise soit", (3*joueurs[joueur]['mains'][0]['mise'] + joueurs[joueur]['mains'][0]['mise'] % 10) // 2)

                joueurs[joueur]['richesse'] += (3*joueurs[joueur]['mains'][0]['mise'] + joueurs[joueur]['mains'][0]['mise'] % 10) // 2
                joueurs[joueur]['mains'][0]['mise'] = 0
                joueurs[joueur]['mains'][0]['jeu'] = []

        if [joueur for joueur in joueurs.keys() if joueurs[joueur]['mains'][0]['mise'] != 0] == []:
            croupier = []


def explosion_joueur(joueur: str, indice_main: int):
    """
    Met à 0 la mise et la main du joueur s'il dépasse 21
    Par ailleurs, une mise de 0 permettra par la suite
    de savoir si un joueur est encore actif dans le tour.
    """
    global joueurs
    affichage(joueur)
    if score(joueurs[joueur]['mains'][indice_main]['jeu'])['min'] > 21:
        print('\n' + joueur + ", vous avez dépassé 21, votre main", indice_main, "perd donc la manche")
        joueurs[joueur]['mains'][0]['mise'] = 0
        joueurs[joueur]['mains'][indice_main]['jeu'] = [[]]


def choix_action(joueur: str, indice_main: int):
    """
    Permet à joueur de décider de ce qu'il fait (rester, tirer...)
    contrairement à choix(joueur: str, txt: str), prend en compte que certains
    choix ne peuvent être faits que sous conditions:
        - doubler: richesse suffisante
        - split: cartes de la main similaires
    """
    global joueurs
    liste_actions = ['rester', 'tirer', 'abandonner']
    doubler = ""
    split = ""

    if joueurs[joueur]['richesse'] >= joueurs[joueur]['mains'][0]['mise']:
        doubler = ", 'doubler"
        liste_actions.append('doubler')

    if joueurs[joueur]['mains'][indice_main]['jeu'][0]['valeur'] == joueurs[joueur]['mains'][indice_main]['jeu'][1]['valeur']:
        split = ", 'split'"
        liste_actions.append('split')

    return choix(joueur + ", voulez-vous 'rester', 'tirer'" + doubler + split + " ou 'abandonner'? ", liste_actions)


def choix_tirer(joueur: str, indice_main: int):
    """
    Distribue une carte au joueur,
    puis lui propose jusqu'à ce que celui-ci atteigne 21 de tirer une carte ou de rester
    """
    global joueurs
    action = 'tirer'
    while action == 'tirer':
        tirer(joueurs[joueur]['mains'][indice_main]['jeu'])

        if score(joueurs[joueur]['mains'][indice_main]['jeu'])['min'] <= 21:
            affichage(joueur)
            action = choix(joueur + ', écrivez "tirer" pour tirer une carte, et "rester" pour rester avec votre main ', ['tirer', 'rester'])

        else:
            action = 'rester'

    explosion_joueur(joueur, indice_main)


def abandonner(joueur: str, indice_main: int):
    """
    Le joueur réccupère perd sa main et la mise qui lui était associée
    L'arrondi pour congruence à 5 de la division de la mise avantage le croupier
    pour empêcher qu'un joueur misant 5 ne puisse garder l'intégralité de sa mise
    """
    global joueurs
    print(joueur, "abandonne avec sa main", indice_main,", il récupère donc la moitié de sa mise soit",
          (joueurs[joueur]['mains'][indice_main]['mise'] - joueurs[joueur]['mains'][indice_main]['mise'] % 10) // 2)

    joueurs[joueur]['richesse'] += (joueurs[joueur]['mains'][0]['mise'] - joueurs[joueur]['mains'][0]['mise'] % 10) // 2
    joueurs[joueur]['mains'][indice_main]['mise'] = 0
    joueurs[joueur]['mains'][indice_main]['jeu'] = []


def split(joueur: str):
    """
    sépare la main du joueur en deux mains et distribue une carte par main.
    Diminue de 1 le prochain indice de main de la prochaine action (pour que la main
    repasse dans la boucle du tour du joueur)si la paire n'est pas d'AS, et
    l'augmente d'un sinon (pour la raison inverse)
    """
    global joueurs, indice_main

    # 3 lignes compliquées car il faut bien que les deux jeux soient des listes indépendantes
    jeu_bis = [{'valeur': joueurs[joueur]['mains'][indice_main]['jeu'][1]['valeur'], 'couleur': joueurs[joueur]['mains'][indice_main]['jeu'][1]['couleur']}]
    main_bis = {'mise': joueurs[joueur]['mains'][indice_main]['mise'], 'jeu': jeu_bis}
    joueurs[joueur]['mains'].insert(indice_main + 1, main_bis)

    del joueurs[joueur]['mains'][indice_main]['jeu'][1]
    # del joueurs[joueur]['mains'][indice_main + 1]['jeu'][0]

    tirer(joueurs[joueur]['mains'][indice_main]['jeu'])
    tirer(joueurs[joueur]['mains'][indice_main + 1]['jeu'])

    if joueurs[joueur]['mains'][indice_main]['jeu'][0]['valeur'] == '1':
        indice_main += 1

    else:
        indice_main -= 1
    # remarque: pas d'explosion possible à 2 cartes


def doubler(joueur: str, indice_main: int):
    """ Double la mise du joueur puis lui fait tirer une carte et le fait exploser si nécessaire"""
    global joueurs
    joueurs[joueur]['richesse'] -= joueurs[joueur]['mains'][indice_main]['mise']
    joueurs[joueur]['mains'][indice_main]['mise'] *= 2
    tirer(joueurs[joueur]['mains'][0]['jeu'])
    explosion_joueur(joueur, indice_main)


def tour_croupier():
    """Fait tirer le croupier jusqu'à ce qu'il etteigne 17"""
    global sabot, croupier, joueurs
    print('\n', "Cartes du croupier:", croupier)
    while score(croupier)['min'] < 17:
        croupier.append(sabot[-1])
        del sabot[-1]
        print('\n', "Cartes du croupier:", croupier)

    if score(croupier)['max'] > 21:
        print("Le croupier a dépassé 21, il perd donc face à tous les joueurs restants")

        for joueur in joueurs.keys():
            for indice_main in range(len(joueurs[joueur]['mains'])):
                if joueurs[joueur]['mains'][indice_main]['mise'] != 0:
                    print('\n', joueur, "a récupère deux fois la mise associée à sa main", indice_main, "soit", 2 * joueurs[joueur]['mains'][indice_main]['mise'])
                    joueurs[joueur]['richesse'] += 2 * joueurs[joueur]['mains'][indice_main]['mise']
                    joueurs[joueur]['mains'][indice_main]['mise'] = 0


def resultats():
    """compare les résultats du joueur à ceux du croupier puis répartie les mises"""
    global joueurs, croupier
    for joueur in joueurs.keys():
        for indice_main in range(len(joueurs[joueur]['mains'])):
            if joueurs[joueur]['mains'][indice_main]['mise'] != 0:

                total_cartes = score(joueurs[joueur]['mains'][indice_main]['jeu'])['max']
                if total_cartes > 21:
                    total_cartes = score(joueurs[joueur]['mains'][indice_main]['jeu'])['min']

                if total_cartes < score(croupier)['min']:
                    print('\n', "la main", indice_main, "de", joueur, "perd face au croupier")

                else:
                    print('\n', "la main", indice_main, "de", joueur, "gagne face au croupier,", joueur,
                          "récupère le double de la mise associée à sa main soit", 2 * joueurs[joueur]['mains'][indice_main]['mise'])

                    joueurs[joueur]['richesse'] += 2 * joueurs[joueur]['mains'][indice_main]['mise']

                print("croupier", croupier)
                print(joueur, joueurs[joueur]['mains'][indice_main])

                joueurs[joueur]['mains'][indice_main] = []

        joueurs[joueur]['mains'] = [{'mise': 0, 'jeu':  []}]

    croupier = []


def eliminations():
    """Elimine joueur et l'annonce si celui-ci n'a plus de richesse"""
    global joueurs
    noms = [nom for nom in joueurs.keys()]
    for joueur in noms:

        if joueurs[joueur]['richesse'] == 0:
            print('\n' + joueur + " n'a plus rien à miser,", joueur, "est éliminé de la partie")
            del joueurs[joueur]


reprendre_partie = choix('Voulez-vous reprendre la partie précédente? Répondez "oui" ou "non": ', ['oui', 'non'])

if reprendre_partie == 'non':
    # Paramétrage du croupier, des joueurs et des IA
    croupier = []
    print()
    nb_joueurs = choix_nb_joueurs()
    joueurs = creation_joueurs()

    # IA = {nom de l'IA: risques pris par l'IA}
    IA = {'René': 0.1, 'Gisèle': 0.05, 'Elisa': 0.06, 'Juliette': 0.07, 'Eloa': 0.08, 'Maïmouna': 0.08, 'Raphaël': 0.09,
        'Roman': 0.1, 'Quentin': 0.11, 'Kévin': 0.12, 'Anne': 0.03, 'Félix': 0.14, 'Sylvie': 0.1, 'Antoine': 0.06}

    creation_IA()

    # Initialisation des richesses (au choix des joueurs), cliquable sur interface
    initialisation_richesses()


else:
    joueurs = initialisation_par_sauvegarde()


# Boucle while des manches:
continuer = 'oui'
while continuer == 'oui':

    # Initialisation des mains
    # pourrait être intégré à distribution() mais placé ici pour faciliter interface
    initialisation_mains()

    # sauvegarde, faite ici et non uniquement après la boucle pour sauvegarder en cas de bug
    sauvegarde()

    # Initialisation du sabot (p, c, k, t = pique, coeur, carreau, trefle)
    sabot = creation_sabot()

    # Première mise des joueurs
    mise()

    # Distribution des cartes
    distribution()

    # Black Jack
    black_jack()

    if croupier != []:

        # Boucle des joueurs
        for joueur in joueurs.keys():

            # Si ni le croupier, ni le joueur n'a fait Black Jack, le joueur, pour chacun de ses jeux, fait un seul choix:
                # Tirer
                # Abandonner
                # Doubler
                # split (uniquement possible si le joueur possède une paire)
                # Rester (pas de fonction associée au bouton car rien à faire)

            indice_main = 0
            while indice_main < len(joueurs[joueur]['mains']):

                if joueurs[joueur]['mains'][indice_main]['mise'] == 0:
                    pass

                elif joueurs[joueur]['intelligence'] == 'humaine':
                    print('\n', 'Carte croupier:', croupier[0])
                    affichage(joueur)
                    action = choix_action(joueur, indice_main)

                    if action == 'tirer':
                        choix_tirer(joueur, indice_main)

                    elif action == 'abandonner':
                        abandonner(joueur, indice_main)

                    elif action == 'doubler':
                        doubler(joueur, indice_main)

                    elif action == 'split':
                        split(joueur)

                else:
                    continue

                indice_main += 1

        # s'il reste des joueurs en lice:
        if [joueur for joueur in joueurs.keys() if mise_totale(joueurs[joueur]['mains']) != 0] != []:

            # Le croupier tire ses cartes et perd s'il a plus de 21
            tour_croupier()

            # Boucle des résultats (une itération par joueur restant):

                # Si main_croupier > main_joueur:
                    # Croupier réccupère la mise du joueur

                # Sinon:
                    # le joueur réccupère 2 fois sa mise

            resultats()

    # les joueurs à richesse nulle sont éliminés de la partie
    eliminations()

    if joueurs == {}:
        print('\n', "Tous les joueurs sont éliminés, la partie est terminée")
        break

    continuer = choix('Voulez-vous continuer? Répondez "oui" ou "non": ', ['oui', 'non'])
    print()

initialisation_mains()
sauvegarde()


"""
from math import *
from random import *
from numpy import random as nprd


#initialisations

couleurs = ['trefle', 'pique', 'coeur', 'carreau']
valeurs = ['as', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'Valet', 'Dame', 'Roi']

BJDict = {

    'croupier' : {'score' : 0, 'bourse' : 0, 'enjeu' :True, 'blackjack' : False, 'burst' : False},
    'joueurs' : {
        0 :{
            'nom':'',
            'type': 0,
            'bourse': ''

            'enjeu' : True
            'blackjack':False
            'burst':False

    }



    }


}


def stratCroupier(BJDict):
    if BJDict['croupier']['score']<17:
        BJDict['croupier']['enjeu'] == True
    else:
        BJDict['croupier']['enjeu'] == True
        print(" Le croupier ne pioche plus")


#CONTRUCTION DE LA PIOCHE pour n joueur on compte des pioches de n*52 cartes ordonnées qu'on mélangera

#on construit un paquet ordonné qui servira pour constituer la pioche
def creation_paquet():
    paquet = []
    for x in couleurs:
        for j in valeurs:
            paquet.append(j "de" x)
    return paquet

#on construit le gros deck de pioche qu'on melange aléatoirement à l'aide de la fonction shuffle
def melange_pioche(n):
    pioche = [] #on initialise une liste vide qui correspond au gros deck de la pioche
    cartes = paquet()
    for i in range(n):
        pioche.extend(cartes) #on ajoute des paquet ordonnés autant de fois qu'il y a de joueurs
    shuffle(pioche) #on mélange la pioche
    return pioche

#le gros deck de pioche est construit

#il faut desormais construire une fonction qui recoit les informations concernant les joueurs et les recense dans le BJDict['joueurs]. on lui demande son nom, son type (humain ou ordinateur), et sa stratégie de jeu

def InfosJoueurs(BJDict, n):
    for i in range(n):
        print()
        GDict['joueurs'][i] = {} #on crée une nouvelle page dans l'onglet [joueurs] du dico


        nom = input('Nom du joueur:') #on demande le nom au joueur
        if nom == ' ': #si il ets invalide (deja pris ou vide), on le signale à l'utilisateur
            print("Vous devez saisir un nom valide")
            continue
        meme_nom = False
        for j in range(i):
            if nom == BJDict['joueurs'][j]['nom']:
                meme_nom = True
        if meme_nom:
            print("Ce nom est déjà pris")
            continue
        else:
            BJDict['joueurs'][i]['nom'] = nom #si tout est bon, on l'ajoute


        typ = int(input("Humain(0) ou Ordinateur(1)? : "))
        if typ != 0 and typ != 1:
            print("Veuillez entrer une valeur valide")
            continue
        BJDict['joueurs'][i]['type'] = typ





#il faut separer le travail en etapes
#1 demande du nombre de joueur
#2 creation de la liste de joueurs
#3 choix du type de joueur (humain ou AI)
#4choix dyu niveau de difficulté des joueurs AI
#5 creation de bourse des joueurs

#on stocke la totalité des informations dnas un unique dictionnaire nommé "BJDict", il contiendra toutes les données liées au jeu en lui meme, les stratégies
"""
